#!/usr/bin/python3.5

'''
# def
	def is executable code, it creates an function object and assigns it to the function names. i.e. a function name is a reference to the function object.
	def name( arg1, arg2, arg3, ... ):
		statements
		[return statement]
	It is a statement in Python, so it can appear anywhere , even nested in other statements. Statements in Python are not allow to appear in place where it expects an expressions.
		
	if X:
		def func():
	else:
		def func1():
	...
	
'''	

'''	
# lambda 
	lambda creates an object but return it as a result.It allows to in-line function definitions in places.
'''

'''
# return
	It sends a result object back to caller, which is different from lambda that returns an object as a result that can be used in direct.
'''

'''
# yeild
	When function reach "return", it returns an object to caller and is removed from stack.Whereas, "yield" return an object but isn't removed from stack that can be reused later.
	Yield is a generator that can be used user-defined iterable objects.
'''

'''
# Scope
	
	The place where you assign a name in source code determines the namespace it will live in, and hence its scope of visibility.
	i.e. Python uses the location of the assignment of a name to associate it with a particular namespace.
	
	Names assigned inside a "def" can only be seen by the code within that "def". You cannot even refer to such names from outside the function. Names assigned in a "def" do not clash with variables outside the"def", even the same names are used elsewhere.
	
	Assigned names are local unless declared global or nonglobal. Python would find the variables from the scope of Local function,Enclosing function, Global and Built-in in order, The LEGB Rule.

	# "global" variable 

		It is the module-level variables. By default, variables assigned in function are locally and removed when function reaches "return".

	# "local" variables

		It only exist in function scope.

	# "nonlocal" variables in 3.X
		
		
	# "build-in" variables
		
		Build-in vars in 3.X are pocessed by all module automatically.
		>>>import builtins
		>>>dir(builtins)
	
	
# Other Scope
	
	1. comprehensions
	2. try statements
	3. Class statements

'''

# Case 1: Local
X = 99; L = 100 # global
def func(): X = 88; print(X, L) # X here is local in func. L which is global here isn't assigned within func so it would find L outside the func.
func()
print( X, L ) # X here is global in module

# Case 2: Global
def func2(): 
	global X; X+=10; print(X) # The X in func2 is declared "globally"
func2()
print(X) # X has changed, due to the global X in func1

# Case 3: Nonlocal
X = 10
def outer():
	X = 100
	def inner():
		nonlocal X; X = 10000
	inner()
	print( X )
outer() # X is nonlocal
print(X) # X is global
''' global and nonlocal are kind of declaration. In fact, they are namespace declaration. '''

# Case 4: built-in
import builtins
print(dir(builtins))

# Notes: 
'''
	Names in Local scope may override vaiables of same name of both global and built-in scope.
'''
def spam():
	open = "ABC"
	print( open )
	f = open("script1.txt") # run into error, because of local var "open" override the built-in var "open".
	print( f.read() )

spam()

'''
# Arguments are called by referenced
	Arguments are passed by referenced, which the mutable data types should be more carefull when objects are shared with the same reference.
'''




