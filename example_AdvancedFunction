#!/usr/bin/python3.5

# Advanced Function

''' Some points are mentioned in the script "example_Function_Scope_Arg". '''

# Recursive
def MySum( L ):
	if not L:
		return 0
	else:
		return L[0] + MySum( L[1:] )

print( MySum( list(range(11) ) ) )

def MyFactorial( num ):
	if not num-1:
		return 1
	else:
		return num * MyFactorial( num-1 )

print( MyFactorial( 10 ) )

''' Alternative '''
def MySum_A( L ):
	return 0 if not L else L[0] + MySum_A( L[1:] )

print( MySum_A( list( range(11) ) ) )

def MyFactorial_A( num ):
	return 1 if not num-1 else num*MyFactorial_A(num-1)

print( MyFactorial_A( 10 ) )

''' Alternative '''
def MySum_B( L ):
	first, *rest = L
	return 0 if not rest else first + MySum_B( rest )

print( MySum_B( list( range(11) ) ) )

''' Alternative ''' 
def MySum_C( first, *rest ):
	''' This doesn't work at all,
		because it expects receives individual argument not iterable
	'''
	return 0 if not rest else first + MySum_C( rest )

print( MySum_C( list(range(10) ) ) )


# Function introspection
''' 
	>>$ func.__name___
		# the name of function
	>>$ dir( func )
		# Check the attributes of the function
	>>$ func.__code__
		# This tools allow us to explore implementation detail -- functions have attached "code objects", which povide details on aspects such as the functions' local variables and arguments. 
	>>$ dir( func.__code__ )
	>>$ func.__code__.co_varnames
		# This shows the variables of the function.
	>>$ func.__code__.co_argcount
		# This shows the amount of the arguments of the function.
'''

# Function Attributions
'''
	Besides the built-in attributes, function also can attach the user-defined attributes as well
	The all internal names( attributes ) are named after double underscores (__X__ ) in order to avoid clashing the names defined by user.
	The built-in attributes of function is a way to emulate "statics local" variables in other languages, whoes names are local to a function but retain after the function exits and killed when program terminates.	
'''
def PrintABC( n ):
	print( "ABC"*n )
print( dir(PrintABC) ) # built-in attributes
''' User-defined attributes '''
PrintABC.count = 0
PrintABC.length = len( "ABC" )
print( dir(PrintABC) ) # add user-defined attributes
print( PrintABC.length ) # Print the value of user-defined attribute


# Function Annotations in 3.X
'''
	Attach annotation information to a function object, which arbitrary user-defined data about a function's arguments and result. When present are simply attached to the function object's .__annotations__ attribute for use by other tools.
	Function annotations are coded in def header lines.
'''
''' Here is normal function below. '''
def sum_noAnnotations( a, b, c ):
	return a + b + c

print( "No annotations: %d" %(sum_noAnnotations( 1,2,3 )) )

''' With annotations '''
def sum_Annotations( a:"arg" = 400, b:int, c:0.9, d:int=16 ) -> int:
	return a + b + c + d

print( "With annotations: %d" %(sum_Annotations( 1,2,3 )) )
print( "func.__annotations__ in dict form: %s " %( sum_Annotations.__annotations__ ) )


