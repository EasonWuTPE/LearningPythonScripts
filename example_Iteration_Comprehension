#!/usr/bin/python3.5


# Iteration:
'''
	1. To check that wether the object is iterable by func iter():
	In for loop e.g. for i in xxx, using iter(xxx) to get the iterator. If xxx has the method  __iter__(), it means xxx is iterable, if not, xxx cannot be traversed.



	2. Start to traverse by func. next(xxx) or method .__next__():
	If xxx is a traversal and iterable object, using function next() or method .__next__() to traverse until the it returns the StopIteration.
'''

# List, Dict, range(), str, tuple, file, zip(), map() and set are iterable.

'''
it1 = iter( 123 ) # 123 is not iterable, lead to error.
print( it1 ) # it1 is not a iterator.
'''

print( [1,2,3].__iter__() ) # Whether [1,2,3] has attribute __iter__()
it2 = iter([1,2,3]) # [1,2,3] is iterable.
print(it2) # it2 is an list iterator.
print( it2.__next__() )
print( next(it2) )
print( next(it2) )
print( next(it2) )

print(range(30).__iter__()) # Whether range(3) has attribute __iter__()
it3 = iter(range(3)) # range(3) is iterable.
print(it3) # it3 is an list iterator.
print( it3.__next__() )
print( next(it3) )
print( next(it3) )
print( next(it3) )

# Some objects are both iterator and iterable.
'''
  File objects support just one iteration, they can't seek backward to support multiple active scans.
  File objects have their own __next__() method and don't need to return a different object. 
'''
f = open( "script1.txt" )
print( f is iter(f) ) # f and iter(f) is iterator.
print( f.__iter__() is iter(f) )  
print( f.__iter__() is f )  

# List and many other built-in objects are not their own iterators because they di support multiple open iterations--for example, there may be multiple iterations in nested loops all at different positions. So it must call iter() to start iterating.
L = [1,2,3]
print( iter(L) is L ) # L is list, iter(L) is iterator



# Comprehension




